use clap::{Parser, ValueEnum};
use std::{
    fmt::Display,
    fs,
    path::{Path, PathBuf},
    process::{Command, Stdio, exit},
};

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
enum Dither {
    Bayer,
    FloydSteinberg,
    Sierra2,
    Sierra2_4a,
    Sierra3,
    Burkes,
    Atkinson,
}

/// Converts a video file to gif format using ffmpeg
#[derive(Parser)]
struct Args {
    /// Input file path (positional)
    #[clap(value_name = "FILE", index = 1)]
    file: PathBuf,

    /// Frames per second
    #[clap(short = 'f', long = "fps", default_value_t = 30)]
    fps: u8,

    /// Scale multiplier for output dimensions (e.g. 0.5 = half size, 2 = double size). Values <= 0 treated as 1.0
    #[clap(short = 's', long = "scale", value_name = "SCALE", conflicts_with_all = ["width", "height"])]
    scale: Option<f32>,

    /// Width of the output file in pixels, use -1 to preserve aspect
    #[clap(short, long, default_value_t = -1)]
    width: i32,

    /// Height of the output file in pixels, use -1 to preserve aspect
    #[clap(short = 'i', long, default_value_t = -1)]
    height: i32,

    /// Which dithering to use, if any
    #[arg(value_enum)]
    #[clap(short = 'd', long = "dither")]
    dither: Option<Dither>,

    /// Output path
    #[clap(short = 'o', long = "output", value_name = "OUT")]
    output: Option<PathBuf>,
}

fn main() {
    let args = Args::parse();
    validate(&args);
    // we need to know the file name for multiple things
    let file_name: &str = args
        .file
        .file_stem()
        .and_then(|it| it.to_str())
        .expect("Could not get file name!");

    println!("scale: {}", get_scale_part(&args));

    gen_palette(args.fps, file_name, &args);

    // Convert the video to GIF using the generated palette
    let output_path = args.output.clone().unwrap_or_else(|| {
        let mut path = PathBuf::from(format!("./{file_name}"));
        path.set_extension("gif");
        path
    });

    let args = Args {
        file: args.file.clone(),
        fps: args.fps,
        // ensure scale is a valid value
        scale: args.scale.map(|s| if s <= 0.0 { 1.0 } else { s }),
        width: args.width,
        height: args.height,
        output: args.output,
        dither: args.dither,
    };

    convert_video(file_name, args, &output_path);

    // cleanup
    remove_palette(file_name);
}

/// will exit with code 1 if any of the args are bad
fn validate(args: &Args) {
    if !args.file.exists() {
        println!("the passed file does not exist");
        exit(1)
    }
}

/// generates the palette to use with the gif for better color accuracy
fn gen_palette(fps: u8, file_name: &str, args: &Args) {
    let file_location = &args.file;
    let palette_name = get_palette_location(file_name);
    let scale = get_scale_part(args);

    let status = Command::new("ffmpeg")
        .arg("-i")
        .arg(file_location)
        .arg("-vf")
        .arg(format!("fps={fps},scale={scale}:flags=lanczos,palettegen"))
        .arg(&palette_name)
        // it's helpful to see the ffmpeg output
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .expect("Failed to run ffmpeg to generate palette");

    if !status.success() {
        if let Some(code) = status.code() {
            eprintln!("ffmpeg exited with status {}", code);
            exit(code);
        } else {
            eprintln!("ffmpeg terminated by signal");
            exit(1);
        }
    }
}

/// Remove the palette file generated by gen_palette, ignoring NotFound errors.
fn remove_palette(file_name: &str) {
    let palette_name = get_palette_location(file_name);
    match fs::remove_file(&palette_name) {
        Ok(_) => (),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => (),
        Err(e) => eprintln!(
            "Failed to remove palette '{palette_name:?}': {e:?}. You may need to clean up this file yourself"
        ),
    }
}

fn convert_video(file_name: &str, args: Args, output_path: &Path) {
    let input_path = args.file.clone();
    let fps = args.fps;
    let palette_name = get_palette_location(file_name);

    let scale_part = get_scale_part(&args);
    let dither_part = get_dither_part(&args);

    let filter =
        format!("fps={fps},scale={scale_part}:flags=lanczos[p];[p][1:v]paletteuse{dither_part}");

    let status = Command::new("ffmpeg")
        .arg("-i")
        .arg(&input_path)
        .arg("-i")
        .arg(&palette_name)
        .arg("-filter_complex")
        .arg(&filter)
        .arg(output_path)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .expect("Failed to run ffmpeg to convert to gif");

    if !status.success() {
        if let Some(code) = status.code() {
            eprintln!("ffmpeg exited with status {code}");
            exit(code);
        } else {
            eprintln!("ffmpeg terminated by signal");
            exit(1);
        }
    }
}

fn get_temp_file(name: &str) -> PathBuf {
    let mut temp = std::env::temp_dir();
    temp.extend([name]);
    temp
}

fn get_palette_location(name: &str) -> PathBuf {
    let name = format!("{name}_palette.png");
    get_temp_file(&name)
}

fn get_scale_part(args: &Args) -> String {
    if let Some(scale) = args.scale {
        format!("iw*{scale}:ih*{scale}")
    } else {
        let width = args.width;
        let height = args.height;
        format!("{width}:{height}")
    }
}

fn get_dither_part(args: &Args) -> String {
    args.dither
        .map(|it| format!("=dither={it}"))
        .unwrap_or_default()
}

impl Display for Dither {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let val = match self {
            Dither::Bayer => "bayer",
            Dither::FloydSteinberg => "floyd_steinberg",
            Dither::Sierra2 => "sierra2",
            Dither::Sierra2_4a => "sierra2_4a",
            Dither::Sierra3 => "sierra3",
            Dither::Burkes => "burkes",
            Dither::Atkinson => "atkinson",
        };
        write!(f, "{val}")
    }
}
