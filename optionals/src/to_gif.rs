use clap::Parser;
use std::{
    fs,
    path::{Path, PathBuf},
    process::{Command, Stdio, exit},
};

/// Converts a video file to gif format using ffmpeg
#[derive(Parser, Debug)]
struct Args {
    /// Input file path (positional)
    #[clap(value_name = "FILE", index = 1)]
    file: PathBuf,

    /// Frames per second
    #[clap(short = 'f', long = "fps", default_value_t = 30)]
    fps: u8,

    /// the scale of the output file as a percentage. Anything below 1 will be treated as 100%
    #[clap(short = 's', long = "scale", value_name = "SCALE", conflicts_with_all = ["width", "height"])]
    /// Scale multiplier for output dimensions (e.g. 0.5 = half size). Values <= 0 treated as 1.0
    scale: Option<f32>,

    /// Width of the output file in pixels, use -1 to preserve aspect
    #[clap(short, long, default_value_t = -1)]
    width: i32,

    /// Height of the output file in pixels, use -1 to preserve aspect
    #[clap(short = 'i', long, default_value_t = -1)]
    height: i32,

    /// Output path
    #[clap(short = 'o', long = "output", value_name = "OUT")]
    output: Option<PathBuf>,
}

fn main() {
    let args = Args::parse();
    validate(&args);
    // we need to know the file name for multiple things
    let file_name: &str = args
        .file
        .file_stem()
        .and_then(|it| it.to_str())
        .expect("Could not get file name!");

    gen_palette(args.fps, file_name, &args.file);

    // Convert the video to GIF using the generated palette
    let output_path = args.output.clone().unwrap_or_else(|| {
        let mut path = PathBuf::from(format!("./{file_name}"));
        path.set_extension("gif");
        path
    });

    let args = Args {
        file: args.file.clone(),
        fps: args.fps,
        // ensure scale is a valid value
        scale: args.scale.map(|s| if s <= 0.0 { 1.0 } else { s }),
        width: args.width,
        height: args.height,
        output: args.output,
    };

    convert_video(file_name, args, &output_path);

    // cleanup
    remove_palette(file_name);
}

/// will exit with code 1 if any of the args are bad
fn validate(args: &Args) {
    if !args.file.exists() {
        println!("the passed file does not exist");
        exit(1)
    }
}

/// generates the palette to use with the gif for better color accuracy
fn gen_palette(fps: u8, file_name: &str, file_location: &Path) {
    let palette_name = format!("{file_name}_palette.png");

    let status = Command::new("ffmpeg")
        .arg("-i")
        .arg(file_location)
        .arg("-vf")
        .arg(format!("fps={fps},palettegen"))
        .arg(&palette_name)
        // it's helpful to see the ffmpeg output
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .expect("Failed to run ffmpeg to generate palette");

    if !status.success() {
        if let Some(code) = status.code() {
            eprintln!("ffmpeg exited with status {}", code);
            exit(code);
        } else {
            eprintln!("ffmpeg terminated by signal");
            exit(1);
        }
    }
}

/// Remove the palette file generated by gen_palette, ignoring NotFound errors.
fn remove_palette(file_name: &str) {
    let palette_name = format!("{file_name}_palette.png");
    match fs::remove_file(&palette_name) {
        Ok(_) => (),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => (),
        Err(e) => eprintln!(
            "Failed to remove palette '{palette_name}': {e:?}. You may need to clean up this file yourself"
        ),
    }
}

fn convert_video(file_name: &str, args: Args, output_path: &Path) {
    let Args {
        file: input_path,
        fps,
        width,
        height,
        scale,
        output: _,
    } = args;
    let palette_name = format!("{file_name}_palette.png");

    let filter = if let Some(s) = scale {
        // s is a multiplier; scale both dimensions by s (e.g. 0.5 halves size)
        format!("fps={fps},scale=iw*{s}:ih*{s},paletteuse=dither=bayer")
    } else {
        format!("fps={fps},scale={width}:{height},paletteuse=dither=bayer")
    };

    let status = Command::new("ffmpeg")
        .arg("-i")
        .arg(input_path)
        .arg("-i")
        .arg(&palette_name)
        .arg("-filter_complex")
        .arg(filter)
        .arg(output_path)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .expect("Failed to run ffmpeg to convert to gif");

    if !status.success() {
        if let Some(code) = status.code() {
            eprintln!("ffmpeg exited with status {code}");
            exit(code);
        } else {
            eprintln!("ffmpeg terminated by signal");
            exit(1);
        }
    }
}
