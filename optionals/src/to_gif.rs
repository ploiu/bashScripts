use clap::Parser;
use std::{
    fs,
    path::{Path, PathBuf},
    process::{Command, Stdio, exit},
};

/// Converts a video file to gif format using ffmpeg
#[derive(Parser, Debug)]
struct Args {
    /// Input file path (positional)
    #[clap(value_name = "FILE", index = 1)]
    file: PathBuf,

    /// Frames per second
    #[clap(short = 'f', long = "fps", default_value_t = 30)]
    fps: u8,

    /// Width for scaling, use -1 to preserve aspect
    #[clap(short, long, default_value_t = -1)]
    width: i32,

    /// Height for scaling, use -1 to preserve aspect
    #[clap(short = 'i', long, default_value_t = -1)]
    height: i32,

    /// Output path
    #[clap(short = 'o', long = "output", value_name = "OUT")]
    output: Option<PathBuf>,
}

fn main() {
    let args = Args::parse();
    // we need to know the file name for multiple things
    let file_name: &str = args
        .file
        .file_stem()
        .and_then(|it| it.to_str())
        .expect("Could not get file name!");

    if !args.file.exists() {
        println!("the passed file does not exist");
        exit(1)
    }

    gen_palette(args.fps, file_name, &args.file);

    // Convert the video to GIF using the generated palette
    let output_path = args.output.unwrap_or_else(|| {
        let mut path = PathBuf::from(format!("./{file_name}"));
        path.set_extension("gif");
        path
    });

    convert_video(
        file_name,
        args.fps,
        args.width,
        args.height,
        &output_path,
        &args.file,
    );

    // cleanup
    remove_palette(file_name);
}

fn gen_palette(fps: u8, file_name: &str, file_location: &Path) {
    let palette_name = format!("{file_name}_palette.png");

    let status = Command::new("ffmpeg")
        .arg("-i")
        .arg(file_location)
        .arg("-vf")
        .arg(format!("fps={fps},palettegen"))
        .arg(&palette_name)
        // it's helpful to see the ffmpeg output
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .expect("Failed to run ffmpeg to generate palette");

    if !status.success() {
        if let Some(code) = status.code() {
            eprintln!("ffmpeg exited with status {}", code);
            exit(code);
        } else {
            eprintln!("ffmpeg terminated by signal");
            exit(1);
        }
    }
}

// Convert the input video to GIF using the generated palette. Inherits stdout/stderr.
fn convert_video(
    file_name: &str,
    fps: u8,
    width: i32,
    height: i32,
    output_path: &Path,
    input_path: &Path,
) {
    let palette_name = format!("{file_name}_palette.png");

    let filter = format!("fps={fps},scale={width}:{height},paletteuse=dither=bayer");

    let status = Command::new("ffmpeg")
        .arg("-i")
        .arg(input_path)
        .arg("-i")
        .arg(&palette_name)
        .arg("-filter_complex")
        .arg(filter)
        .arg(output_path)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .expect("Failed to run ffmpeg to convert to gif");

    if !status.success() {
        if let Some(code) = status.code() {
            eprintln!("ffmpeg exited with status {}", code);
            exit(code);
        } else {
            eprintln!("ffmpeg terminated by signal");
            exit(1);
        }
    }
}

// Remove the palette file generated by gen_palette, ignoring NotFound errors.
fn remove_palette(file_name: &str) {
    let palette_name = format!("{file_name}_palette.png");
    match fs::remove_file(&palette_name) {
        Ok(_) => (),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => (),
        Err(e) => eprintln!(
            "Failed to remove palette '{palette_name}': {e:?}. You may need to clean up this file yourself"
        ),
    }
}
